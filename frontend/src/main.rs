use proto::HelloRequest;
use sycamore::futures::spawn_local_scoped;
use sycamore::prelude::*;
use tonic_web_wasm_client::Client;
use wasm_bindgen::prelude::*;

mod proto {
    tonic::include_proto!("hello"); // The string specified here must match the proto package name
}

use proto::greeter_client::GreeterClient;

// First up let's take a look of binding `console.log` manually, without the
// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations
// manually ourselves, and the correctness of our program relies on the
// correctness of these annotations!

#[wasm_bindgen]
extern "C" {

    // Use `js_namespace` here to bind `console.log(..)` instead of just
    // `log(..)`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // The `console.log` is quite polymorphic, so we can bind it with multiple
    // signatures. Note that we need to use `js_name` to ensure we always call
    // `log` in JS.
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // Multiple arguments too!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);
}

#[component]
fn App<G: Html>() -> View<G> {
    log("Hello, World!");
    let base_url = "http://localhost:50051".to_string(); // URL of the gRPC-web server
    let mut query_client = GreeterClient::new(Client::new(base_url)); // `QueryClient` is the client generated by tonic
    let mut request = HelloRequest::default();
    request.name = "Kobold".to_uppercase();
    log("Hello, World!");
     spawn_local_scoped(async move{
    log("Hello, World!");
    let response = query_client.say_hello(request).await.unwrap().into_inner();
    log(response.message.as_str());
    });

    view! {
        p { "Hello, World!" }
    }
}

fn main() {
    sycamore::render(|| {
        view! {
            App{}
        }
    });
}
